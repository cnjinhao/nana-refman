|name	=nana::listbox
|header	=<nana/gui/widgets/listbox.hpp>
|decl	=#class listbox;#
:The listbox represents a list of informations from which the user can select.

==base==
[[widget_object<category::widget_tag>]//./widgets/widget_object_widget_tag.htm] : public [[widget]]

==events==
[[general events]//./core/events.htm]
#checked(const [[arg_listbox]]&)#
:occurs when an item is checked or unchecked.
#selected(const [[arg_listbox]]&)#
:occurs when an item is selected or unselected.
#category_dbl_click(const [[arg_listbox_category]]&)#[#1.3]
:occurs when a category is double clicked.


==member types==
index_pair
:the representation of a category/item
index_pairs
:a set of index_pairs, a standard container, possibly #std::vector<index_pair>#
size_type
:an unsigned integral type
[[cat_proxy]/widgets/listbox-cat_proxy][#1.5.4]
:iterator to access category
[[item_proxy]/widgets/listbox-item_proxy][#1.5]
:iterator to access item
iresolver
:the input resolver that converts an object to an item
oresolver
:the output resolver that converts an item to an object
export_options
:the options of exporting items into a string variable
[[column_interface]][#1.5]
:column operations


==scheme==
#header_bgcolor#
:background color of header columns
#header_fgcolor#[#1.5]
:foreground color of header columns
#header_grabbed#
:background color of grabbed header column
#header_floated#
:background of header column when it is grabbed and moved
#item_selected#
:background color of item when it is selected
#item_highlighted#[#1.5]
:background color of item when it is highlighted
#selection_box#[#1.5]
:the color of selection box
#max_fit_content#[#1.4]
:the max column width which is generated by fit_content is allowed, in pixels. It is ignored when it is 0, or a non-zero value is passed to fit_content()
#min_column_width#
:the minimum width of column, excluding the suspension_width
#suspension_width#
:width of "..." in pixels
#text_margin#[#1.4]
:left/right margin to the text to determine the cell width. Width of cell = text_margin * 2 + text width + 1
#header_height#
:height of header, in pixels
#text_height#[#1.4.1]deprecated
:text height of item, in pixels. It will be set by the listbox with current font
#item_height_ex#
:extra height of item, in pixels.
#item_height#[#1.4.1]deprecated
:height of item, in pixels. It will be set by the listbox with forumal item_height = text_height + item_height_ex
#header_splitter_area_before#
:response area before header splitter
#header_splitter_area_after#
:response area after header splitter
#mouse_wheel#
:the number of lines/characters to scroll when vertical/horziontal mouse wheel is moved


==member functions==
constructors
:constructs a listbox widget instance
decl=#listbox();#
decl=#listbox(window handle, bool visible);#
decl=#listbox(window handle, const rectangle& ={}, bool visible = true);#
:Constructs the listbox
:0) Default constructor, it constructs the object of listbox, but it doesn't create UI element.
:1,2) Constructs the instance and creates UI element of the listbox.
--parameters--
handle
:a handle to a parent widget for the listbox widget.
visible
:a boolean flag that specifies the visibility of the listbox after creating.
--end--

---Associative element access---
assoc[#1.4]
:access specified category
decl=#template<typename Key> [[cat_proxy]] assoc(Key&& key);#
:Returns the category that is mapped to the specified key, it inserts a new category if such key does not exist.
:Iterators are invalidated if an insertion is performed.
--parameters--
key
:the key of the category to return
--returns--
:The mapped [[cat_proxy]] associated with the key.
--see also--
assoc_at
--end--

assoc_at[#1.4]
:access specified category with bounds checking
decl=#template<typename Key> [[cat_proxy]] assoc_at(Key&& key);#
decl=#template<typename Key> const [[cat_proxy]] assoc_at(Key&& key) const;#
:Returns the mapped category which is associated with the key. Bounds checking is performed, exception of type #std::out_of_range# will be thrown if suck key does not exist.
--parameters--
key
:the key of the category to return
--returns--
:The mapped [[cat_proxy]] associated with the key.
--except--
std::out_of_range
:if such key doesn't exist.
--see also--
assoc
--end--

assoc_erase[#1.4]
:erases a category
decl=#template<typename Key> void erase_key(const Key& key);#
decl=#template<typename Key> void erase_key(Key&& key);#
:Removes a category which is associated with the specified key. If the key does not exist, no category will be removed.
--parameters--
key
:a key object indicates a category to remove
--end--

---Column access---
column_at[#1.5]
:access a specified column with bounds-checking
decl=#[[column_interface]]& column_at(size_type pos, bool disp_order = false);#
decl=#const [[column_interface]]& column_at(size_type pos, bool disp_order = false) const;#
:Returns a reference to the column at specified location pos. Bounds checking is performed.
--parameters--
pos
:location of the column to access.
disp_order
:Indicates whether the pos is display positon or absolute position. If this parameter is #true#, the pos represents display position. If the parameter is #false#, the pos represents absolute position.
--returns--
:a reference of column to the requested position.
--except--
std::out_of_range
:if #!(pos < column_size())#
--end--

column_from_pos
:returns the position of column by a specified point
decl=#size_type column_from_pos(const point & pos) const;#
:Returns the absolute position of column which contains the specified point.
--parameters--
pos
:the point to be checked
--returns--
:the absolute position of the column, #nana::npos# otherwise.
--end--

column_movable[#1.7]
:enables/disables the movement of the column
decl=#void column_movable(bool movable);#
decl=#bool column_movable() const;#
:When the column is not movable, user can't move a column by dragging it.
--parameters--
movable
:Indicates whether the column can be moved.
--returns--
:1) #true# if the column can be moved, #false# otherwise.
--end--

column_resizable[#1.7]
:enables/disables the resizability of the column.
decl=#void column_resizable(bool resizable);#
decl=#bool column_resizable() const;#
:When the column is not resizable, it doesn't show a west-east cursor when user moves the cursor to a gap between two columns, and the column can't be resized by dragging the gap.
--parameters--
resizable
:Indicates whether the column can be resized.
--returns--
:1) #true# if the column can be resized, #false# otherwise.
--end--

column_size
:returns the number of columns
decl=#size_type column_size() const;#
:Returns the number of columns in the listbox.
--returns--
:The number of columns in the listbox.
--end--

move_column[#1.7]
:moves column to the view position
decl=#void move_column(size_type abs_pos, size_type view_pos);#
:Moves a column at specified position to a position where it will be shown.
:If abs_pos or view_pos is out of range, this function does nothing.
--parameters--
abs_pos
:The absolute position of column object in the listbox
view_pos
:The position where the column is shown.
--end--

reorder_columns[#1.7]
:sorts columns
decl=#void reorder_columns(size_type first_col, size_type last_col, index_pair row, bool reverse, std::function<bool(const std::string&,size_type,std::string&,size_type,const any* rowval, bool)> comp)#
:Sorts columns in range[first_col, last_col] inclusive using a row.
--parameters--
first_col
:The absolute position of the first column
last_col
:The absolute position of the last column
row
:Position of an item which is used for comparing
reverse
:reversely comparing
comp
:a weak ordering comparer
--end--

---Element access---
at
:access a spcecifed content with bounds checking
decl=#[[cat_proxy]] at(size_type pos);#
decl=#const [[cat_proxy]] at(size_type pos) const;#
decl=#[[item_proxy]] at(const index_pair& abs_pos);#
decl=#const [[item_proxy]] at(const index_pair& abs_pos) const;#
:Returns an iterator to the content at specified location pos. Bounds checking is performed, exception of type #std::out_of_range# will be thrown on invalid access.
:    0,1) Access a category.
:    2,3) Access an item.
--parameters--
pos
:location of the category to access.
abs_pos
:absolute position of the item to access.
--returns--
:an iterator to the requested position.
--except--
std::out_of_range
:if pos is invalid.
--see also--
operator[]
--end--

operator[][#1.4]
:access a specified content without bounds checking
decl=#[[cat_proxy]] operator[](size_type pos);#
decl=#const [[cat_proxy]] operator[](size_type pos) const;#
decl=#[[item_proxy]] operator[](const index_pair& abs_pos);#
decl=#const [[item_proxy]] operator[](const index_pair& abs_pos) const;#
:Returns an iterator to the content at specified location pos. No bounds checking is performed, therefore the behavior is undefined if location pos is invalid.
:    0,1) Access a category.
:    2,3) Access an item.
--parameters--
pos
:location of category to access.
abs_pos
:absolute position of item to access.
--returns--
:an iterator to the requested position.

--see also--
at
--end--

---Observers---
checked
:returns indexes of all checked items
decl=#selection checked() const;#
:Returns indexes of all checked items in all categories. A checked item is that the toggle of an item is checked when the listbox is checkable.
--returns--
:selection, a std container that contains a set of index_pair elements which point to checked items.
--end--

selected
:returns indexes of all selected items
decl=#selection selected() const;#
:Returns indexes of all check items in all categories. A selected item is that an item is highlighted by clicking.
--returns--
:selection, a std container that contains a set of index_pair elements which point to checked items.
--end--

visible_header
:determines the visibility of the listbox header
decl=#bool visible_header() const;#
:Determines the visibility of the listbox header.
--returns--
:#true# if the header is visible, #false# otherwise.
--end--

---Operations---
append_header
:appends a new column
decl=#size_type append_header(std::string text, unsigned width = 120);#
decl=#size_type append_header(std::wstring text, unsigned width = 120);#
:Appends a new column at the end.
--parameters--
text
:The title of the new column. The only UTF-8 encoded string is accepted for #std::string# overloading.
width
:The width of column, in pixel.
--returns--
:the index of new column.
--end--

auto_draw
:enables/disables automatic drawing
decl=#void auto_draw(bool enable);#
:When a certain operation is performed, listbox redraws for the updated state, this is a useful feature which makes the listbox in the latest display state.
:
:But in some situations the fact that automatically performed drawing may be redundant, for example, appending items in a loop will performs redraw many times, it may cause low efficent. In this case, automatic drawing should be disabled before entering the loop, and then, re-enable automatic drawing after loop finished. When re-enable automatic drawing, the listbox will perform drawing for refresh UI.
--parameters--
enable
:indicates whether to enable or disable the auto-draw.
--end--

avoid_drawing[#1.4]
:performs a function
decl=#template<typename Function> void avoid_drawing(Function fn);#
:It's a helper function that performs a specified function. It disables automatic drawing during performing, re-enables automatic drawing after performing. An implement of avoid_drawing
```
template<typename Function>
void avoid_drawing(Function fn)
{
	this->auto_draw(false);
	try
	{
		fn();
	}
	catch (...)
	{
		this->auto_draw(true);
		throw;
	}
	this->auto_draw(true);
}
```
--parameters--
fn
:an function object to perform
--end--

category_icon[#1.5.4]
:modifies the category icon
decl=#listbox& category_icon(std::function<void(paint::graphics& graph, const rectangle& rt_icon, bool expanded)> icon_renderer);#
decl=#listbox& category_icon(const [[paint::image]/paint/image]& img_expanded, const [[paint::image]/paint/image]& img_collapsed);#
:Modifies the category icon
:  0), Sets a renderer for category icon
:  1), Sets category icons.
```
//A possible implementation of the second category_icon.
listbox& category_icon(const paint::image& img_expanded, const paint::image& img_collapsed)
{
	return this->category_icon([img_expanded, img_collapsed](paint::graphics& graph, const rectangle& rt_icon, bool expanded)
	{
		if (expanded)
		{
			img_expanded.stretch(rectangle{ img_expanded.size() }, graph, rt_icon);
		}
		else
		{
			img_collapsed.stretch(rectangle{ img_collapsed.size() }, graph, rt_icon);
		}
	});
}
```
--parameters--
icon_renderer
:A rendering function
img_expanded
:An image is shown when the category is expanded
img_collapsed
:An image is shown when the category is img_collapsed
--returns--
:The reference of #*this#.
--end--

checkable
:enables/disables the checkable listbox item.
decl=#void checkable(bool enable);#
:Enables/disables the listbox item to be checkable. If a listbox is checkable, it shows an extra toggle in front of item text.
--parameters--
enable
:indicates whether to enable or disable the listbox to be checkable.
--except--
any exception
:throws what fn throws
--end--

enable_single/disable_single
:enables/disables single selection/check
decl=#void disable_single(bool for_selection);#
decl=#void enable_single(bool for_selection, bool category_limited);#
:Enables/disables the listbox whether the user is allowed to select/check more than one item at a time.
--parameters--
for_selection
:indicates whether the operation is applied for selection or is applied for check of an item.
category_limited
:indicates whether the user is allowed to select/check another item in different categories. If this parameter is #true#, the user can select/check another item in different categories. If the parameter is #false#, the user only can select/check one item in all categories.
--end--

is_single_enabled[#1.7]
:determines whether the single selection/check is enabled
decl=#bool is_single_enabled(bool for_selection) const noexcept;#
:Determines whether the single selection/check is enabled.
--parameters--
for_selection
:indicates whether the operation is applied for selection or is applied for check of an item.
--returns--
:#true# if the single selection/check is enabled, #false# otherwise. 
--end--


hovered[#1.7]
:returns the hovered item
decl=#index_pair hovered(bool return_end) const;#
:It returns the position of hovered item. When there is not a hovered item, it returns an empty position or end position depending on the parameter return_end.
```
if(list.hovered(false).empty())
{
	//No item is hovered.
}

//Inserts the all selected items in list to the list2 at the position of the hovered.
//If there is not a hovered item, the selected items are appended to the list2.
list2.insert_item(list2.hovered(true), list, list.selected());
```
--parameters--
return_end
:indicates whether to return an end position instead of empty position if no item is hovered.
--returns--
:The position of the hovered item. If return_end is true, it returns the position next to the last item of last category if no item is hovered.
--end--

scroll[#1.2]
:scrolls the view to the bottom/top
decl=#void scroll(bool to_bottom, size_type cat_pos = ::nana::npos);#
decl=#void scroll(bool to_bottom, const index_pair& pos);#
:Scrolls the category or item to the bottom/top.
--parameters--
to_bottom
:indicates whether to scroll the view to the bottom or the top.
cat_pos
:specifies a category to scroll. If it is npos, scrolls the last category.
pos
:specifies the item to scroll.
--end--

show_header
:shows/hides the listbox header
decl=#void show_header(bool show);#
:Shows/hides the listbox column header.
--parameters--
show
:indicates whether to show or hide the listbox column header.
--end--

---Modifiers---
append
:appends a new category at the end
decl=#[[cat_proxy]] append(std::string name);#
decl=#void append(std::initializer_list<std::string> names);#
:Appends categories.
--parameters--
name
:The name of new category
names
:The names of new categories, specified by initializer list
--returns--
:the [[cat_proxy]] refers to the new category.
--end--

clear
:clears items of a specified category
decl=#void clear(size_type pos);#
decl=#void clear();#
:Removes all items from a specified category, the category itself will not be removed.
:  0) Removes all items from a specified category.
:  1) Removes all items from all categories.
--parameters--
pos
: the position of a category which its items will be removed.
--except--
std::out_of_range
:if pos is not less than the number of categories. 
--end--

erase[#1.5]
:erases categories
decl=#void erase(size_type pos);#
decl=#void erase();#
decl=#void erase(index_pairs indexes);#[#1.5]
decl=#[[item_proxy]] erase([[item_proxy]] item);#
:Removes categories, all items of the category will be removed as well.
:  0) Removes a specified category.
:  1) Removes all categories.
:  2) Removes specified items at one time. It is faster than 3) if many items to be delete.
:  3) Removes a specified item.
--parameters--
pos
:the position of a category.
item
:an iterator pointing to an item removed.
indexes
:positions of items to be deleted.
--returns--
:3) returns an iterator to the next of the removed item.
--except--
std::out_of_range
:if pos isn't less than the number of categories.
--end--

insert
:inserts a new category
decl=#[[cat_proxy]] insert([[cat_proxy]] pos, std::string text);#
decl=#[[cat_proxy]] insert([[cat_proxy]] pos, std::wstring text);#
:Inserts a new category before pos.
--parameters--
pos
:the position before which a category will be inserted.
text
:the title of the new category. #std::string# is for UTF-8 encoded string.
--returns--
:a [[cat_proxy]] pointing to the new category inserted.
--except--
std::out_of_range
:if pos is invalid.
--end--

insert_item[#1.7]
:inserts a new item
decl=#void insert_item(const index_pair& abs_pos, std::string text);#
decl=#void insert_item(const index_pair& abs_pos, std::wstring text);#
decl=#void insert_item(index_pair abs_pos, const listbox& rhs, const index_pairs& indexes);#[#1.7]
:Inserts new item(s)
:  0,1) Inserts an item before a specified absolute position.
:  2) Copies items from an existing listbox.
--parameters--
abs_pos
:the absolute position before which an item will be inserted.
text
:the title of the new item, #std::string# is for UTF-8 encoded string.
rhs
:another listbox which provides items to be copied.
indexes
:indexes of the items to be copied.
--except--
std::out_of_range
:if abs_pos is invalid.
--end--

---Ordering---
sortable
:enables/disables sort
decl=#bool sortable() const;#
decl=#void sortable(bool enable);#
:When a listbox is sortable, users can click a column header to sort the items of the column.
:  0), Determines whether the listbox is sortable.
:  1), Enables/disables the sort.
--parameters--
enable
:Indicates whether to enable or disable the sort.
--returns--
:0), #true# if the listbox is sortable, #false# otherwise.
--end--

freeze_sort
:temporarily prevents automatic sorting
decl=#bool freeze_sort(bool freez);#
:Sets a flag to prevent automatic sorting. For example, freezing sort before many insertion operations avoids redundant sorting for each insertion operation.
--end--

set_sort_compare
:Sets a strict weak ordering comparer
decl=#void set_sort_compare(size_type col, std::function<bool(const std::string& text_l, any* any_l, const std::string& text_r, any* any_r, bool reverse)> strick_ordering);#
:
:Compares 2 items through the text of items.
```
bool compare(	const std::string& text_l, any*,
		const std::string& text_r, any*,
		bool reverse)
{
	return (reverse ? text_l > text_r : text_l < text_r);
}
```
:Compares 2 items through the custom objects.
```
bool compare(	const std::string&, any* any_l,
		const std::string&, any* any_r,
		bool reverse)
{
	if(any_l && any_r) 	//some items may not attach a customer object.
	{
		int * il = any_cast<int>(any_l);
		int * ir = any_cast<int>(any_r);
		return (il && ir && (reverse ? *il > *ir : *il < *ir));
 		// ^ some types may not be int.
	}
	return false;
}

auto cat = listbox.at(0);
cat.at(0).value(10); //10 is custom data.
cat.at(1).value(20); //20 is custom data.
```
--parameters--
strick_ordering
:A strick weak ordering comparar, it must requires: Irreflexivity (comp(x, x) returns #false#) and Antisymmetry(comp(a, b) != comp(b, a) returns #true#)
--end--

sort_col
:sorts a specified column
decl=#size_type sort_col() const;#
decl=#void sort_col(size_type col, bool reverse = false);#
:Sorts the specified column.
:  0), Returns the current sorted column.
:  1), Sorts the specified column. It also keeps the column for automatic sort when an item changes. This method has a side-effect that potentially invalidates any existing reference between display position and absolute position.
--parameters--
col
:A column to request. If this parameter is nana::npos, it cancels automatic sorting.
reverse
:Indicates whether to sort reversely.
--returns--
:0), the sorted column. It returns nana::npos if no sorted column has set.
--end--

unsort
:cancels automatic sorting
decl=#void unsort();#
:Cancels automatic sorting. This method has side-effect that potentially invalidates any existing reference between display position and absolute position.
:
:A possible implementation.
```
void unsort()
{
	this->sort_col(nana::npos, false);
}
```
--end--

---Visible range---
first_visible[#1.7]
:returns first visible element
decl=#index_pair first_visible() const;#
:It may return an item or a category item.
--returns--
:the index of first visible element.
--end--

last_visible[#1.7]
:returns last visible element
decl=#index_pair last_visible() const;#
:It may return an item or a category item.
--returns--
:the index of last visible element.
--end--

visibles[#1.7]
:returns all visible items
decl=#index_pairs visibles() const;#
:It returns all visible items that are displayed in listbox window area.
--returns--
:index_pairs containg all visible items.
--end--

==remark==
:Before appending items to the listbox, a header has to be created. The header describes columns of the listbox.
```
//nana::listbox list;
list.append_header("Name");
list.append_header("Age");
```
:A category is used to group items. Listbox provides a default category whose index is zero.
```
auto cat = list.at(0); //access the default category.

cat.append({"Jack", "20"});	//Insert an item

cat.push_back("Rose");		//Insert another item
cat.back().text(1, "21");
```
:Automatic drawing is a feature that listbox automatically refreshs UI when an insertion/deleting/modification of items occurs. But if a listbox inserts a hunders of items, the automatic drawing will cause low efficent. So the automatic drawing should be disabled before insertion.
```
auto cat = list.at(0);

list.auto_draw(false);	//Disable automatic drawing
for(auto & person : container) //Many items
{
	cat.push_back(person.name);
	cat.back().text(1, person.age);
}
list.auto_draw(true);	//Re-enable automatic drawing

//OR
list.avoid_drawing([&cat, &container]
{
	for(auto & person : container) //Many items
	{
		cat.push_back(person.name);
		cat.back().text(1, person.age);
	}
});
```
:
:Other Links
:
:[[Using STL container]//https://github.com/cnjinhao/nana/wiki/Using-STL-Sequence-Container]
:The listbox category can attach an existing standard sequence container. 
:
:[[Associative Category]//https://github.com/cnjinhao/nana/wiki/Listbox-Associative-Category]
:An easy way to address a category.
:
:[[Inline widgets]//https://github.com/cnjinhao/nana/wiki/Creating-Inline-Widgets-for-Listbox]
:Create nested widgets into the listbox items. 

==see also==
[[arg_listbox]]
[[arg_listbox_category]]
[[cat_proxy]/widgets/listbox-cat_proxy]
[[item_proxy]/widgets/listbox-item_proxy]
[[column_interfae]]